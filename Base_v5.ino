#include <Wire.h>
#include <SPI.h>
#include <RH_RF95.h>
#include <Adafruit_SSD1306.h>
#include <Adafruit_GFX.h>

#define SCREEN_WIDTH 128     // OLED display width, in pixels
#define SCREEN_HEIGHT 32     // OLED display height, in pixels
#define OLED_RESET -1        // Reset pin # (or -1 if sharing Arduino reset pin)
#define SCREEN_ADDRESS 0x3C  ///< See datasheet for Address; 0x3D for 128x64, 0x3C for 128x32
#define DEBUG false

Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);
byte canWeLeave = 1;

const unsigned char ray[] PROGMEM = {
  0x00, 0x02, 0xc0, 0x00, 0x00, 0x06, 0x40, 0x00, 0x00, 0x04, 0x40, 0x00, 0x00, 0x06, 0xc0, 0x00,
  0x3f, 0xdf, 0xfb, 0xf8, 0xff, 0xff, 0xff, 0xfe, 0x7f, 0xff, 0xff, 0xfe, 0x1f, 0xff, 0xff, 0xf8,
  0x0f, 0xff, 0xff, 0xf0, 0x07, 0xff, 0xff, 0xe0, 0x03, 0xff, 0xff, 0xc0, 0x03, 0xff, 0xff, 0x80,
  0x01, 0xff, 0xff, 0x80, 0x00, 0xff, 0xff, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x7f, 0xfc, 0x00,
  0x00, 0x3f, 0xf8, 0x00, 0x00, 0x1f, 0xf0, 0x00, 0x00, 0x03, 0x90, 0x00, 0x00, 0x01, 0x00, 0x00,
  0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
  0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
  0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
const unsigned char hollowRay[] PROGMEM = {
  0x00, 0x02, 0xc0, 0x00, 0x00, 0x06, 0x40, 0x00, 0x00, 0x04, 0x40, 0x00, 0x00, 0x06, 0xc0, 0x00,
  0x3f, 0xdd, 0x7b, 0xf8, 0xe0, 0x70, 0x1e, 0x0e, 0x70, 0x00, 0x00, 0x0e, 0x1c, 0x00, 0x00, 0x18,
  0x0e, 0x00, 0x00, 0x30, 0x06, 0x00, 0x00, 0x60, 0x03, 0x00, 0x00, 0xc0, 0x03, 0x00, 0x00, 0x80,
  0x01, 0x80, 0x01, 0x80, 0x00, 0xc0, 0x03, 0x00, 0x00, 0x40, 0x06, 0x00, 0x00, 0x70, 0x0c, 0x00,
  0x00, 0x3c, 0x18, 0x00, 0x00, 0x1f, 0xf0, 0x00, 0x00, 0x03, 0x90, 0x00, 0x00, 0x01, 0x00, 0x00,
  0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
  0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
  0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
const unsigned char noRay[] PROGMEM = {
  0x00, 0x00, 0xc0, 0x00, 0x00, 0x04, 0x40, 0x00, 0x00, 0x04, 0x40, 0x00, 0x00, 0x06, 0xc0, 0x00,
  0x3f, 0xdf, 0xfb, 0xf8, 0xff, 0xff, 0xff, 0xfe, 0x7f, 0xef, 0xef, 0xfe, 0x1f, 0xe7, 0xcf, 0xf8,
  0x0f, 0xf3, 0x9f, 0xf0, 0x07, 0xf9, 0x3f, 0xe0, 0x03, 0xfc, 0x7f, 0xc0, 0x03, 0xf9, 0x3f, 0x80,
  0x01, 0xf3, 0x9f, 0x80, 0x00, 0xe7, 0xcf, 0x00, 0x00, 0x6f, 0xee, 0x00, 0x00, 0x7f, 0xfc, 0x00,
  0x00, 0x3f, 0xf8, 0x00, 0x00, 0x1f, 0xf0, 0x00, 0x00, 0x03, 0x90, 0x00, 0x00, 0x01, 0x00, 0x00,
  0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
  0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
  0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
const unsigned char ray0[] PROGMEM = {
  0x00, 0x02, 0xc0, 0x00, 0x00, 0x06, 0x40, 0x00, 0x00, 0x04, 0x40, 0x00, 0x00, 0x06, 0xc0, 0x00,
  0x3f, 0xdd, 0x7b, 0xf8, 0xe0, 0x70, 0x1e, 0x0e, 0x70, 0x00, 0x00, 0x0e, 0x1c, 0x00, 0x00, 0x18,
  0x0e, 0x00, 0x00, 0x30, 0x06, 0x00, 0x00, 0x60, 0x03, 0x00, 0x00, 0xc0, 0x03, 0x00, 0x00, 0x80,
  0x01, 0x83, 0x81, 0x80, 0x00, 0xc3, 0x83, 0x00, 0x00, 0x43, 0x86, 0x00, 0x00, 0x70, 0x0c, 0x00,
  0x00, 0x3c, 0x18, 0x00, 0x00, 0x1f, 0xf0, 0x00, 0x00, 0x03, 0x90, 0x00, 0x00, 0x01, 0x00, 0x00,
  0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
  0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
  0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
const unsigned char ray1[] PROGMEM = {
  0x00, 0x02, 0xc0, 0x00, 0x00, 0x06, 0x40, 0x00, 0x00, 0x04, 0x40, 0x00, 0x00, 0x06, 0xc0, 0x00,
  0x3f, 0xdd, 0x7b, 0xf8, 0xe0, 0x70, 0x1e, 0x0e, 0x70, 0x00, 0x00, 0x0e, 0x1c, 0x00, 0x00, 0x18,
  0x0e, 0x00, 0x00, 0x30, 0x06, 0x07, 0xc0, 0x60, 0x03, 0x1f, 0xf0, 0xc0, 0x03, 0x18, 0x30, 0x80,
  0x01, 0x83, 0x81, 0x80, 0x00, 0xc3, 0x83, 0x00, 0x00, 0x43, 0x86, 0x00, 0x00, 0x70, 0x0c, 0x00,
  0x00, 0x3c, 0x18, 0x00, 0x00, 0x1f, 0xf0, 0x00, 0x00, 0x03, 0x90, 0x00, 0x00, 0x01, 0x00, 0x00,
  0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
  0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
  0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
const unsigned char ray2[] PROGMEM = {
  0x00, 0x02, 0xc0, 0x00, 0x00, 0x06, 0x40, 0x00, 0x00, 0x04, 0x40, 0x00, 0x00, 0x06, 0xc0, 0x00,
  0x3f, 0xdd, 0x7b, 0xf8, 0xe0, 0x70, 0x1e, 0x0e, 0x70, 0x0f, 0xe0, 0x0e, 0x1c, 0x3f, 0xf8, 0x18,
  0x0e, 0x70, 0x1c, 0x30, 0x06, 0x47, 0xc4, 0x60, 0x03, 0x1f, 0xf0, 0xc0, 0x03, 0x18, 0x30, 0x80,
  0x01, 0x83, 0x81, 0x80, 0x00, 0xc3, 0x83, 0x00, 0x00, 0x43, 0x86, 0x00, 0x00, 0x70, 0x0c, 0x00,
  0x00, 0x3c, 0x18, 0x00, 0x00, 0x1f, 0xf0, 0x00, 0x00, 0x03, 0x90, 0x00, 0x00, 0x01, 0x00, 0x00,
  0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
  0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
  0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// Array of all bitmaps for convenience. (Total bytes used to store images in PROGMEM = 432)
const unsigned char* raydio[4] = {
  hollowRay,
  ray0,
  ray1,
  ray2

};

// Valuse for animation
int offset[] = { -1, 0, 1, 0 };
int dot = 2;
int bob = 0;
byte bbyte = 0;
byte bbuf = 0;
RH_RF95 rf95(12, 6);
byte bc = 0;
byte button = 0;
byte x = 0;
byte y = 0;
uint8_t pres[1500];
uint8_t time[1500];

int LED = 13;  //Status LED is on pin 13
long timeSinceLastPacket = 0;
int packetCounter = 0;  //Counts the number of packets sent

// The broadcast frequency is set to 921.2, but the SADM21 ProRf operates
// anywhere in the range of 902-928MHz in the Americas.

float frequency = 921.2;  //Broadcast frequency
uint8_t buf[RH_RF95_MAX_MESSAGE_LEN];
uint8_t len = sizeof(buf);

void connectionCheck() {
  while (true) {
    //Display on OLED
    display.clearDisplay();
    display.setTextSize(1);
    display.setTextColor(SSD1306_WHITE);
    display.setCursor(0, 0);
    display.cp437(true);

    if (rf95.available()) {
      // Should be a message for us now
      uint8_t buf[RH_RF95_MAX_MESSAGE_LEN];
      uint8_t len = sizeof(buf);

      if (rf95.recv(buf, &len)) {
        digitalWrite(LED, HIGH);         //Turn on status LED
        timeSinceLastPacket = millis();  //Timestamp this packet
        display.println((char*)buf);



        // Send a reply - always.  Might be interesting to send different messages based on user input or no message at all
        uint8_t toSend[] = "Howdy!";
        rf95.send(toSend, sizeof(toSend));
        rf95.waitPacketSent();
        display.display();
        digitalWrite(LED, LOW);  //Turn off status LED
        canWeLeave = 0;
      }
    } else {
      SerialUSB.println("discard");
      display.clearDisplay();
      display.setCursor(0, 0);
      if (analogRead(0) < 1000) {
        display.drawBitmap(96, 1 + (offset[bob % 4]), ray, 32, 32, SSD1306_WHITE);
      } else {
        display.drawBitmap(96, 1 + (offset[bob % 4]), noRay, 32, 32, SSD1306_WHITE);
        }
      display.print("Conecting");

      for (int i = 0; i < (dot % 4); i++) {
        display.print(".");
      }

      delay(200);
      display.println();
      bob++;
      if (bob % 2 == 0) { dot++; }
      display.display();
    }

    if (canWeLeave == 0) {
      display.clearDisplay();
      break;
    }
  }
}



void setup() {
  pinMode(2, INPUT);
  pinMode(3, INPUT);
  SerialUSB.begin(9600);

  delay(3000);

  if (!display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS)) {
    if (DEBUG) SerialUSB.println(F("SSD1306 allocation failed"));
    for (;;)
      ;  // Don't proceed, loop forever
  }

  //Initialize the Radio.
  if (rf95.init() == false) {
    while (1)
      ;
  }

  rf95.setFrequency(frequency);
  rf95.setTxPower(14, false);
  display.clearDisplay();
  display.display();

  connectionCheck();
}



void loop() {
  display.clearDisplay();
  display.setCursor(0, 0);
  display.println("Float has");
  display.println("Connected");
  display.println("The Rays");
  display.println("Team Number:2");
  if (bc < 20) {
    display.drawBitmap(96, 1 + (offset[bob % 4]), ray, 32, 32, SSD1306_WHITE);
    bbyte = 0;
  } else {
    bbyte = 1;

      if (bob % 4 == 0) { display.drawBitmap(96, 1 + (offset[bob % 4]), hollowRay, 32, 32, SSD1306_WHITE); }
        if (bob % 4 == 1) { display.drawBitmap(96, 1 + (offset[bob % 4]), ray0, 32, 32, SSD1306_WHITE); }
        if (bob % 4 == 2) { display.drawBitmap(96, 1 + (offset[bob % 4]), ray1, 32, 32, SSD1306_WHITE); }
        if (bob % 4 == 3) { display.drawBitmap(96, 1 + (offset[bob % 4]), ray2, 32, 32, SSD1306_WHITE); }
        }
  if (dot % 20 == 0) { bob++; }
  dot++;
  if ((bbyte == 1) && (not bbyte == bbuf)) {
    SerialUSB.println("press");
    uint8_t toSend[] = "go";
    rf95.send(toSend, sizeof(toSend));
    rf95.waitPacketSent();
  }
  bbuf = bbyte;

  display.display();
  if (analogRead(0) > 1000) {
    button = 1;
    bc = bc + 1;
  } else {
    button = 0;
    bc = 0;
  }
  // Send Go

  // reciving data
  if (rf95.available()) {
    uint8_t buf[RH_RF95_MAX_MESSAGE_LEN];
    uint8_t len = sizeof(buf);

    if (rf95.recv(buf, &len)) {
      digitalWrite(LED, HIGH);         //Turn on status LED
      timeSinceLastPacket = millis();  //Timestamp this packet

      delay(50);

      display.display();
      digitalWrite(LED, LOW);  //Turn off status LED

      // Receive the Data
      if (((char*)buf)[0] == (char)"x"[0] or ((char*)buf)[0] == (char)"a"[0]) {
        for (int i = 0; i < sizeof(buf) - 1; i++) {
          pres[i] = buf[i];
        }
        x = 1;
      }

      if (((char*)buf)[0] == (char)"y"[0] or ((char*)buf)[0] == (char)"c"[0]) {
        for (int i = 0; i < sizeof(buf) - 1; i++) {
          time[i] = buf[i];
        }
        y = 1;
      }

      // if the data is recieved
      if ((x == 1) && (y == 1)) {
        y = 0;
        x = 0;
        display.setCursor(0, 0);
        display.clearDisplay();
        display.println("Data Receved!");
        display.println("Ready to Dive");
        display.display();

        // Send Data to python script
        for (int i = 0; i < 5 - 1; i++) {
          SerialUSB.println((char*)pres);
          delay(500);
          SerialUSB.println((char*)time);
          delay(500);
        }
      }
    }
  }
}